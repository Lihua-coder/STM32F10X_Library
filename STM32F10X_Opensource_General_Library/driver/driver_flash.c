/*********************************************************************************************************************
* 本文件是STM32F10X 开源库的一部分
* 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
* 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
*
* 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
* 甚至没有隐含的适销性或适合特定用途的保证
* 更多细节请参见 GPL
* 欢迎各位使用并传播本程序 但修改内容时必须保留版权声明（即本声明）
*
*
* 修改记录
* 日期              作者           备注
* 2026-01-01        Lihua      first version
********************************************************************************************************************/
#include "driver_flash.h"

flash_data_union flash_union_buffer[FLASH_PAGE_SIZE / 4];   /* 1 kB 页缓冲，256×32 bit */

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：解锁 Flash 控制器（私有）
// 参数说明：无
// 返回参数：无
// 使用示例：flash_unlock();
// 备注信息：必须解锁后才能进行擦除/编程
//-------------------------------------------------------------------------------------------------------------------
static void flash_unlock(void)
{
    if (FLASH->CR & FLASH_CR_LOCK) {
        FLASH->KEYR = FLASH_KEY1;
        FLASH->KEYR = FLASH_KEY2;
    }
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：等待 Flash 操作完成（私有）
// 参数说明：无
// 返回参数：0-成功  1-失败
// 使用示例：if(flash_wait_done()){ /* error */ }
// 备注信息：轮询 BSY 位，检测到 EOP 后清除
//-------------------------------------------------------------------------------------------------------------------
static uint8 flash_wait_done(void)
{
    while (FLASH->SR & FLASH_SR_BSY);
    if (FLASH->SR & FLASH_SR_EOP) {
        FLASH->SR = FLASH_SR_EOP;
        return 0;
    }
    return 1;   /* error */
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：校验指定页是否为 0xFF（空页检测）
// 参数说明：page_num      页号（0~63）
// 返回参数：0-空页  1-非空或页号非法
// 使用示例：if(flash_check(63) == 0){ /* 可安全写入 */ }
// 备注信息：先用其判断是否需要擦除
//-------------------------------------------------------------------------------------------------------------------
uint8 flash_check(uint32 page_num)
{
    if (page_num >= 64) return 1;
    uint32 *p = (uint32 *)FLASH_PAGE(page_num);

    for(uint16 i = 0; i < FLASH_PAGE_SIZE / 4; i++) {
        if (p[i] != 0xFFFFFFFF) return 1;
    }
    return 0;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：擦除一整页（1 kB）
// 参数说明：page_num      页号（0~63）
// 返回参数：无
// 使用示例：flash_erase_page(63);  // 最后一页
// 备注信息：擦除后全页为 0xFF；在写入前调用
//-------------------------------------------------------------------------------------------------------------------
void flash_erase_page(uint32 page_num)
{
    if (page_num >= 64) return;
    flash_unlock();
    flash_wait_done();

    FLASH->CR |= FLASH_CR_PER;          /* 页擦除位 */
    FLASH->AR  = FLASH_PAGE(page_num);  /* 擦除地址 */
    FLASH->CR |= FLASH_CR_STRT;         /* 触发擦除 */
    flash_wait_done();

    FLASH->CR &= ~FLASH_CR_PER;         /* 关闭页擦除 */
    FLASH->CR |= FLASH_CR_LOCK;         /* 重新加锁 */
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：读取一页数据到用户缓冲区
// 参数说明： page_num       页号（0~63）
// 参数说明： buf            用户提供的 32-bit 数组
// 参数说明： len            要读取的 32-bit 字数（≤256）
// 返回参数： 无
// 使用示例：uint32 buf[256]; flash_read_page(63, buf, 256);
// 备注信息：通过 flash_read_page_to_buffer 间接调用
//-------------------------------------------------------------------------------------------------------------------
void flash_read_page(uint32 page_num, uint32 *buf, uint16 len)
{
    if(page_num >= 64) return;
    uint32 *src = (uint32 *)FLASH_PAGE(page_num);

    for(uint16 i = 0; i < len; i++) buf[i] = src[i];
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：将用户缓冲区写入一整页
// 参数说明：page_num       页号（0~63）
// 参数说明：buf            待写入的 32-bit 数组
// 参数说明：len            要写入的 32-bit 字数（≤256）
// 返回参数：
// 使用示例：flash_write_page(63, buf, 256);
// 备注信息：写入前须保证页已擦除；通过 flash_write_page_from_buffer 间接调用
//-------------------------------------------------------------------------------------------------------------------
void flash_write_page(uint32 page_num, const uint32 *buf, uint16 len)
{
    if(page_num >= 64) return;
    flash_unlock();
    flash_wait_done();

    FLASH->CR |= FLASH_CR_PG;
    uint32 *dst = (uint32 *)FLASH_PAGE(page_num);

	for(uint16 i = 0; i < len; i++){
        /* 关键：仅当目标位可写时才写，防止 Bits 从 0 变 1 触发 WRPRTERR */
        if((dst[i] & buf[i]) != buf[i]){
            FLASH->CR &= ~FLASH_CR_PG;
            FLASH->CR |= FLASH_CR_LOCK;
            return;                 /* 用户可选择先擦除再重写 */
        }
        dst[i] = buf[i];
        flash_wait_done();
    }
    FLASH->CR &= ~FLASH_CR_PG;
    FLASH->CR |= FLASH_CR_LOCK;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：将指定页数据读到全局 union 缓冲
// 参数说明：page_num      页号（0~63）
// 返回参数：无
// 使用示例：flash_read_page_to_buffer(63);
// 备注信息：
//-------------------------------------------------------------------------------------------------------------------
void flash_read_page_to_buffer(uint32 page_num)
{
    flash_read_page(page_num, (uint32 *)flash_union_buffer, FLASH_PAGE_SIZE / 4);
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：将全局 union 缓冲写入指定页
// 参数说明：page_num      页号（0~63）
// 返回参数：0-成功  1-页非空（需先擦除）
// 使用示例：if(flash_write_page_from_buffer(63) == 0){ /* 写入成功 */ }
// 备注信息：内部先调用 flash_check 判断是否为空
//-------------------------------------------------------------------------------------------------------------------
uint8 flash_write_page_from_buffer(uint32 page_num)
{
    if(flash_check(page_num) != 0) return 1;   /* 非空，拒绝写入 */
    flash_write_page(page_num, (const uint32 *)flash_union_buffer, FLASH_PAGE_SIZE / 4);
    return 0;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介：清空全局 union 缓冲为 0xFF
// 参数说明：无
// 返回参数：无
// 使用示例：flash_buffer_clear();
// 备注信息：写新数据前调用，避免旧数据干扰
//-------------------------------------------------------------------------------------------------------------------
void flash_buffer_clear(void)
{
    for(uint16 i = 0; i < FLASH_PAGE_SIZE / 4; i++)
        ((uint32 *)flash_union_buffer)[i] = 0xFFFFFFFF;
}


